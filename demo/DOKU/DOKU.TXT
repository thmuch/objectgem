ACHTUNG: Diese Datei entspricht NICHT der neuesten ObjectGEM-Version.
DafÅr ist jetzt aber die Anleitung als TEX-DVI-File zum Ausdrucken
vorhanden (OGEM_DVI.ZIP).

WICHTIG: Diese Doku wurde aus einem TEX-File erzeugt. Leider hat dabei
die DarstellungsqualitÑt etwas gelitten :-), ich werde mich aber bei
zukÅnftigen Versionen um ein besseres optisches Outfit kÅmmern.
Aber es gibt ja mittlerweile auch das  g e d r u c k t e  Handbuch...


Das
ObjectGEM
Programmierhandbuch
Version 1.17


Das vorliegende Handbuch ist urheberrechtlich geschÅtzt. Alle Rechte vorbehalten.
Jegliche VervielfÑltigung auf fotografischem, mechanischem, elektronischem oder
anderem Wege bedarf der schriftlichen Genehmigung durch den Autor.

Die in diesem Buch erwÑhnten Markenzeichen, Firmennamen, Software- und
Hardwareprodukte sind nicht gesondert gekennzeichnet, unterliegen aber
trotzdem dem jeweiligen gesetzlichen Schutz.

ObjectGEM und Dokumentation Copyright 1992-94 Thomas Much
"ObjectGEM in Beispielen" Copyright 1994 Jan Pilgenrîder @ AC3



Auf dem Atari ST/STE/TT/Falcon bricht ein neues Zeitalter des Software-Engineering
an! Aber sehen und lesen Sie selbst...

ObjectGEM ist eine Sammlung von Units fÅr PurePascal, mit der komplexe GEM-Programme
wesentlich einfacher als bisher erstellt werden kînnen. Mit ObjectGEM wird es auch mîglich, daû
alle Programme, die z.Z. auf GEM verzichten, weil sie z.B. nur irgendwelche Statusausgaben machen,
korrekt und mit nur geringem Mehraufwand unter GEM implementiert werden. Auûerdem
kînnen Dialoge mit allen State-of-the-Art-Buttons etc. versehen werden, der Rest (Verwaltung,
Redraw, Auswertung) geschieht dann automatisch. Wer allerdings unbedingt mîchte, kann sich auch
bis zur untersten Stufe der GEM-Programmierung mit einklinken - OOP macht's mîglich!
ObjectGEM-Programme sind im Vergleich zu anderen Bibliotheken recht groû. Dabei muû man
aber die Tatsache bedenken, daû objektorientierte Programmierung eigentlich noch nie auf den
Speicherbedarf geachtet hat (das liegt in der Natur der Sache...). DafÅr ist der Funktionsumfang aber
betrÑchtlich, denn selbst das kleinste ObjectGEM-Programm weiû bereits, wie ein komplettes
GEM-Fenster zu funktionieren hat. Auûerdem kommt es in der heutigen Zeit mehr darauf an, in mîglichst
kurzer Zeit Programme zu schreiben, die leicht zu bedienen sind, sicher laufen und gut erweitert
bzw. gewartet werden kînnen; der Speicherbedarf tritt dabei zunehmend in den Hintergrund.
Trotzdem belegt ObjectGEM immer nur soviel Speicher wie gerade nîtig, da so ziemlich alles dynamisch
verwaltet wird. Und auûerdem: Wer einmal mit ObjectGEM angefangen hat, wird bestimmt nicht so
schnell wieder damit aufhîren!
ObjectGEM ist an neuere AES-Versionen (4.x), MultiTOS und Mag!C angepaût, d.h. es ist z.B.
mîglich, Dialoge im Hintergrund zu bedienen (Buttons anklicken etc.)! FÅr X/Unix-Benutzer steht
sogar ein entsprechender Mausposition-abhÑngiger Eingabemodus zur VerfÅgung. In Vorbereitung
ist auûerdem der GEM-Wizard, mit dem ObjectGEM-Programme mit ein paar Mausklicks generiert
werden kînnen!

fÅr Atari ST, STE, TT, Falcon mit PurePascal, mind. 1 MB RAM und Festplatte
Shareware, daher nur DM 50,- RegistrierungsgebÅhr (DM 60,- incl. Handbuch)
incl. aller Quelltexte
autom. Dialogabarbeitung (optional auch "von Hand")
ebenso einfache Behandlung von Fenstern und MenÅs
Fensterdialoge (auch im Hintergrund bedienbar!)
Fenster-Toolbars und -MenÅs unter allen TOS-Versionen
automatische XAcc- und AV-Protokoll-Behandlung
Iconification (auch ICFS), Drag&Drop
kontextsensitive Bubble-Help (s. Mac System 7)
ausfÅhrliche Online-Hilfe innerhalb der PP-Shell

Und wen es interessiert: Ein Test von ObjectGEM 1.00 findet sich im ST-Magazin 
7/93, S.22 ff.!

Nun aber genug der Vorrede, viel Spaû und Erfolg mit ObjectGEM!

ObjectGEM ist ein Shareware-Produkt. Das Programmpaket darf beliebig 
weitergegeben werden, sofern die Units (d.h. die Quelltexte mit den 
dazugehîrigen Dateien (Beispielprogramme, Dokumentation etc.) zusammen
weitergegeben werden. Jeder kann dann in Ruhe ein biûchen mit ObjectGEM 
herumprobieren. Wer allerdings lÑnger mit ObjectGEM programmiert (egal, ob die 
Programme verîffentlicht werden oder nicht), muû sich registrieren lassen.

Die Registrierung kostet DM 50,- (bzw. DM 60,- mit Handbuch). Das ist -
im Vergleich zu kommerziell angebotenen Bibliotheken - nicht sehr viel.
Trotzdem dÅrfen Programme, die mit 
einer registrierten ObjectGEM-Version erstellt wurden, ohne etwaige 
LizenzgebÅhren weitergegeben, verkauft etc. werden.

öberweisen Sie dazu DM 50,- (bzw. DM 60,-) auf das Konto:


Thomas Much, Sparkasse Karlsruhe,

Kto. 935 30 95, BLZ 660 501 01

(Ihre Adresse nicht vergessen!)


oder schicken sie einen Verrechnungsscheck Åber diesen Betrag an:


Softdesign Computer Software

c/o Thomas Much, Gerwigstraûe 46, 76131 Karlsruhe


Sie kînnen den Betrag auch auf folgendes Konto Åberweisen:


Thomas Much, Postgiroamt Karlsruhe,

Kto. 314881-753, BLZ 660 100 75


Dann muû allerdings mit z.Z. bis zu vier Wochen Wartezeit gerechnet werden (die 
Post...). Wichtig: Wenn Sie einen Scheck aus dem Ausland schicken und diesen 
nicht in DM ausstellen, berechnen Sie bitte DM 8,- extra! Wenn Sie aus dem 
Ausland Åberweisen, machen Sie dies bitte so, daû der EmpfÑnger keine 
zusÑtzlichen GebÅhren zahlen muû. Danke!

Sie erhalten dann umgehend die aktuelle Version - es sei denn, Sie geben bei 
Ihrer Registrierung die Versionsnummer der Ihnen vorliegenden ObjectGEM-Unit 
an; ist diese Version noch aktuell, erhalten Sie erst dann eine Diskette
zugeschickt, wenn eine neue Version verîffentlicht wird (wer also auf jeden 
Fall und sofort eine Disk bekommen mîchte, sollte bei seiner Registrierung 
keine Versionsnummer angeben...). Auûerdem haben Sie dann die Mîglichkeit, 
jederzeit mit einer formatierten 3,5" Diskette und einem frankierten und 
addressierten RÅckumschlag ein evtl. vorhandenes ObjectGEM-Update direkt beim 
Autor (Adresse s.u.) zu bekommen. Kosten wird dies nur dann etwas, wenn der 
Registrierpreis steigen sollte. Die neueste Version ist aber auch per Modem 
Åber die Maus-Mailboxen KA, AC3 und HL zu beziehen (und vermutlich auch in
einigen anderen Mailboxen erhÑltlich).

Der Vertrieb Åber PD-Versender, Mailboxen, Diskettenzeitschriften etc. ist 
erlaubt und ausdrÅcklich erwÅnscht! Dann mîge man sich aber bitte um die
aktuelle Version bemÅhen.

Achtung: Zusammen mit ObjectGEM darf der VDI-Enhancer weitergegeben werden. 
PD-Versender mÅssen vor der Weitergabe aber erst prÅfen, ob sie die entsprechenden
Bedingungen erfÅllen. Ist dies nicht der Fall, mÅssen sie den Enhancer 
aus dem ObjectGEM-Paket entfernen!

Da ObjectGEM mit dem vollstÑndigen Quelltext ausgeliefert wird, hat die 
Shareware-Version keinerlei EinschrÑnkungen mehr. Ich hoffe aber trotzdem, daû
sich dies nicht negativ auf die Registrierungsmoral auswirkt - ich wÅrde mich 
freuen, wenn alle diejenigen, die sich bisher wegen PP-KompatibilitÑtsproblemen
oder dem fehlenden Quelltext nicht registrieren lassen wollten (dies 
wurde mir von sehr vielen Leuten mitgeteilt), nun die Weiterentwicklung 
finanziell unterstÅtzen wÅrden.

Die registrierte Vollversion von ObjectGEM ist incl. Handbuch fÅr DM 60,-
auch bei whiteline erhÑltlich:


whiteline Konzeption, delta labs software

B. Artz & T. Kohl, Rembrandtstraûe 1, 42329 Wuppertal

Tel. & Fax (0202) 734361

Kontakt im MausNet: Tom Kohl @ W


Wichtig: Wer ObjectGEM mehr als nur zu Testzwecken einsetzt und sich nicht
registrieren lÑût, verwendet eine Raubkopie!!!


Die Installation sollte keine groûen Probleme bereiten. Kopieren Sie einfach 
alle Pascal-Dateien (*.PAS) in Ihr Unit-Verzeichnis (dort, wo auch TOS.PPU,
GEM.PPU etc. stehen) bzw. in das Verzeichnis, in dem Sie sonst die Quelltexte
Ihrer Units ablegen, und GOBJECTS.HLP in das Help-Verzeichnis (dort sollten
auch PP.HLP etc. zu finden sein). Fertig!

Die Units werden nun wie gewohnt mit der -Klausel eingebunden. Wenn Sie 
Ihr erstes ObjectGEM-Programm compilieren, werden dann zunÑchst alle ObjectGem-
Units erzeugt (das dauert etwas).

Um in die öbersicht der Online-Hilfe zu gelangen, suchen Sie unter "Help - 
Help..." (oder mit ) am besten nach "ObjectGEM" oder 
"GObjects". Ansonsten bringen Sie den Cursor auf eine fragliche Konstante 
oder Methode und drÅcken , woraufhin eine ErklÑrung dazu erscheinen sollte. 
Dabei ist es egal, ob Sie z.B. nach "Style" oder "Attr.Style" suchen - wenn 
es mehrere Mîglichkeiten gibt, erhalten Sie ein AuswahlmenÅ.

Wenn Sie meinen, einen Fehler in der Online-Hilfe gefunden zu haben (falscher 
oder fehlender Verweis, falsche oder nicht ausreichende Beschreibung), setzen 
Sie sich bitte mit mir (dem Autor) in Verbindung. Danke.

Falls Probleme mit oder Fragen zu ObjectGEM auftauchen sollten, kînnen Sie dies 
dem Autor direkt mitteilen. Bitte benutzen Sie den telefonischen Weg nur in 
dringend FÑllen oder bei kurzen Fragen. Wenn Sie ausfÅhrlichere Antworten 
wÅnschen, schicken Sie bitten einen Brief mit folgenden zusÑtzlichen Angaben:

ObjectGEM-Version
PurePascal-Version bzw. -Datum
Rechner, Speicherausbau, Grafikkarte
TOS-Version

(öbrigens: Da ObjectGEM Shareware ist, ist bei solchen Anfragen gegen 
beiliegendes RÅckporto nichts einzuwenden...)
[3mm]

Softdesign Computer Software

c/o Thomas Much, Gerwigstraûe 46, 76131 Karlsruhe

Tel.: (0721) 62 28 41 (am besten Mo-So zwischen 19 und 22 Uhr)
[3mm]

Am liebsten werden natÅrlich Anfragen von registrierten ObjectGEM-Anwendern
beantwortet, aber falls grundsÑtzliche Fragen bestehen, haben auch potentielle
KÑufer eine Chance (da Sie dies aber offensichtlich in gedruckter Form lesen,
werden Sie hîchstwahrscheinlich auch registriert sein).

Als registrierter Anwender haben Sie auûerdem die Mîglichkeit, Updates (die 
alle paar Wochen erscheinen) durch Einsenden einer formatierten 3,5"-Diskette 
und eines frankierten und addressierten RÅckumschlags zu erhalten. Wenn Sie 
dies "prÑventiv" machen (d.h. am besten sofort wieder nach Erhalt eines 
Updates), bekommen Sie das nÑchste Update zugeschickt, sobald es verfÅgbar ist. 
Und wenn Sie sowieso schon dabei sind, eine Update-Diskette einzuschicken, 
wÑre es nett, wenn Sie dann auch das Anwenderprofil ausdrucken (Datei REGISTR.TXT),
ausfÅllen und mitschicken kînnten (besten Dank im vorraus!).

Wer ein Modem besitzt, kann sich natÅrlich die neuesten Versionen selbst saugen 
(und kann damit auf die Diskette verzichten). Neue Versionen sind zuerst in 
den Maus-Mailboxen KA und AC3 sowie in der ASH-Mailbox verfÅgbar. Das Anwenderprofil kann dann auch an die 
folgende EMail-Adresse geschickt werden:
[3mm]

MausNet: Thomas Much @ KA2oder
[3mm]
Internet: UK48@ibm3090.rz.uni-karlsruhe.de
[4mm]

Maus KA, (0721) 358887, kein Gastdownload von 18.00 bis 21.45

Maus AC3, (0241) 54540, kein Gastdownload!

ASH-Mailbox, (06221) 303671

(dort jeweils die Datei GOBJ_1xx.ZIP im îffentlichen Programmteil)
[3mm]

Auûerdem ist ObjectGEM auf folgenden ftp-Sites zu finden:


ftp.uni-muenster.de /pub/atari/Programming/gobj_1xx.zip

ftp.uni-kl.de /pub/atari/programming/gobj_1xx.zip

Diese EinfÅhrung soll zeigen, wie man mit ObjectGEM schnell und einfach eigene 
GEM-Programme schreiben kann. Ich gehe dabei nicht allzusehr in die Tiefe und 
ich werde auch nicht jeden einzelnen Befehl beschreiben (wer nÑheres zu den 
einzelnen Befehlen wissen will, mîge einen Blick in die Online-Hilfe werfen - 
die Online-Hilfe ist wirklich gut und beschreibt jeden Befehl in aller 
AusfÅhrlichkeit.
Stattdessen werde ich versuchen, zu zeigen, wie man die einzelnen Befehle 
zusammenfÅgt.

Diejenigen, die mit den Grundbegriffen der GEM-Programmierung und der 
objektorientierten Programmierung nicht vertraut sind, sollten sich jetzt 
erst einmal schlau machen - diese EinfÅhrung kann die Grundlagen nicht 
liefern. Das PurePascal-Handbuch sollte aber ausreichen, um das nîtige Wissen 
zu vermitteln.

Es gibt einige Elemente, die in jedem ObjectGEM-Programm vorkommen mÅssen. 
Schauen wir uns dazu mal das kleinstmîgliche Programm an:

PROGRAM Minimal;

USES

OWindows;

VAR

MyApplication: TApplication;

BEGIN
MyApplication.Init('MINI','Minimal');
MyApplication.Run;
MyApplication.Done
END.

ZunÑchstmal mÅssen wir die Unit OWindows benutzen. In dieser Unit stehen die 
wichtigsten Objekte und Methoden (eine Liste findet sich in der Online-Hilfe). 
Dann mÅssen wir unser Applikations-Objekt, das fÅr die Initialisierung und den 
Message-Loop des Programms zustÑndig ist, anlegen. Wir definieren eine 
Variable MyApplication als Object vom Typ TApplication und initialisieren diese 
Instanz von TApplication mit . Dabei ist 
'MINI' der Cookie, der beim Programmstart im Cookie-Jar eingetragen wird,
und 'Minimal' der Name der Applikation.

kÅmmert sich dann um die Routienearbeit, wÑhrend das Programm 
lÑuft, und beendet das Programm.

Dieses Minimal-Programm kann sogar schon einiges. Es baut ein Fenster auf und 
verwaltet es - man kann also mit diesem Fenster alles machen, was man so von 
Fenstern gewohnt ist. Das Programm wird beendet, wenn man drÅckt
oder das Fenster schlieût.

Mit dem Fenster aus MINIMAL.PAS kann man allerdings noch nicht viel Sinnvolles 
anfangen, und manchmal mîchte man in seinem Programm Åberhaupt kein Fenster 
(oder kein Haupt-Fenster) haben. Wenn wir an diesem Fenster etwas Ñndern wollen, 
mÅssen wir dazu die Methode, die es anlegt, Åberschreiben. Diese Methode heiût 
und ist eine Methode des Objektes TApplication; sie wird 
innerhalb von TApplication.Init aufgerufen. Dazu legen wir uns ein von 
TApplication abgeleitetes Objekt an, indem wir die Methode InitMainWindow
neu schreiben. Das ganze sieht dann so aus:

PROGRAMM Minimal;

TYPE

PMyApplication = ^TMyApplication;
TMyApplication = OBJECT(TApplication)
PROCEDURE InitMainWindow; VIRTUAL;
END;

VAR

MyApplication: TMyApplication;

PROCEDURE TMyApplication.InitMainWindow;

BEGIN
END;

BEGIN
MyApplication.Init('MINI','Minimal');
MyApplication.Run;
MyApplication.Done
END.

Anstatt ein Fenster anzulegen, macht unser neues InitMainWindow einfach 
gar nichts.

Dialoge und Alert-Boxen kommen nun wirklich in fast jedem GEM-Programm vor, 
deshalb mîchte ich auch gleich damit anfangen. Dazu dann auch gleich wieder 
ein Beispiel:

PROGRAM Kleines;

USES

OWindows,OTypes,ODialogs;

I KLEINES.I
	
TYPE

TMyApplication = OBJECT(TApplication)
PROCEDURE InitInstance; VIRTUAL;
PROCEDURE InitMainWindow; VIRTUAL;
END;

PInfoMenu = ^TInfoMenu;
TInfoMenu = OBJECT(TKeyMenu)
PROCEDURE Work; VIRTUAL;
END;

POpenDialog = ^TOpenDialog;
TOpenDialog = OBJECT(TKeyMenu)
PROCEDURE Work; VIRTUAL;
END;

PMyDialog =	^TMyDialog;
TMyDialog =	OBJECT(TDialog)
FUNCTION OK: BOOLEAN; VIRTUAL;
FUNCTION Cancel: BOOLEAN; VIRTUAL;
END;

VAR

MyApplication: TMyApplication;
Buffer : RECORD
Kette: STRING[21];
O1,O2: INTEGER
END;

PROCEDURE TMyApplication.InitInstance;

BEGIN
LoadResource('KLEINES.RSC','');
LoadMenu(main_menu);
NEW(PInfoMenu,Init(@SELF,K_Ctrl,Ctrl_I,
menu_info,desk_menu));
NEW(POpenDialog,Init(@SELF,K_Ctrl,Ctrl_D,
menu_open_dialog,file_menu));
INHERITED InitInstance;
SetQuit(menu_quit,file_menu)
END;

PROCEDURE TMyApplication.InitMainWindow;

BEGIN
END;

PROCEDURE TInfoMenu.Work;

BEGIN
IF ADialog=NIL THEN
NEW(ADialog,Init(NIL,'öber KLEINES',
info_dial));
IF ADialog <> NIL THEN ADialog^.MakeWindow
END;

PROCEDURE TOpenDialog.Work;

BEGIN
IF ADialog=NIL THEN
BEGIN
ADialog:=NEW(PMyDialog,Init(NIL,
'KLEINES öbungsprogramm',
main_dial));
IF ADialog<>NIL THEN
BEGIN
NEW(PButton,Init(ADialog,md_ok,id_ok,
TRUE,'Zeigt Eingaben in einer Alertbox
an und beendet das Programm.'));
NEW(PButton,Init(ADialog,md_cancel,id_cancel,
TRUE,'Beendet Programm, ohne Daten
Anzuzeigen.'));
NEW(PEdit,Init(ADialog,md_edit,21,
'Hier kann Text eingegeben werden.'));
NEW(PGroupBox,Init(ADialog,md_option_box,
'Optionen','In dieser Box befinden sich
zwei RadioButtons'));
NEW(PRadioButton,Init(ADialog,md_option1,TRUE,
'Die erste Option'));
NEW(PRadioButton,Init(ADialog,md_option2,TRUE,
'Die zweite Option'));
ADialog^.TransferBuffer:=@Buffer
END
END;
IF ADialog<>NIL THEN ADialog^.MakeWindow
END;

FUNCTION TMyDialog.OK: BOOLEAN;
VAR Valid : BOOLEAN;
Ausgabe: STRING;

BEGIN
Valid:=INHERITED OK;
IF Valid=TRUE THEN
BEGIN
Ausgabe:='In die Editzeile wurde "+Buffer.Kette
+' eingegeben. Es wurde der Radio
button ";
IF Buffer.O1=bf_checked THEN Ausgabe:=Ausgabe+'1'
ELSE
Ausgabe:=Ausgabe+'2';
Ausgabe:=Ausgabe+'. Option ausgewÑhlt.';
Application^.Alert(NIL,1,0,Ausgabe,' Ok');
OK:=TRUE
END
ELSE
OK:=FALSE
END;

FUNCTION TMyDialog.Cancel: BOOLEAN;

BEGIN
IF Application^.Alert(NIL,2,2,'Wirklich Beenden?',
' Abbruch| Ok')=2 THEN
Cancel:=TRUE
ELSE
Cancel:=FALSE
END;

BEGIN
MyApplication.Init('KLNS','Kleines');
MyApplication.Run;
MyApplication.Done
END.

Wir haben einen groûen Teil des letzten Programmes einfach Åbernehmen kînnen. 
Wir haben immer noch unser Applikations-Objekt MyApplication, wir haben immer 
noch das gleiche alte Dialog-Objekt TMyDialog (an OK und Cancel hat sich 
eigentlich nur geÑndert, daû wir dort nicht mehr den Befehl zum Beenden des Programms
geben).
Es hat sich aber auch einiges geÑndert: Wir haben zwei neue Objekte 
TOpenDialog und TInfoMenu (beide abgeleitet vom Typ mit den 
Åberschriebenen Methoden und TInfoMenu.Work). In 
TMyApplication.InitInstance ist einiges dazu gekommen, und dafÅr macht 
InitMainWindow Åberhaupt nichts mehr.

Ehe wir unsere MenÅzeile benutzen kînnen, mÅssen wir natÅrlich erst einmal die
Resource geladen haben. Wir erinnern uns, daû wir das in der Methode
gemacht hatten. Direkt nach dem Laden der Resource
kînnen wir dann mit der Installation unseres MenÅs loslegen:

PROCEDURE TMyApplication.InitInstance;

BEGIN
LoadResource('KLEINES.RSC','');
LoadMenu(main_menu);
NEW(PInfoMenu,Init(@SELF,K_Ctrl,Ctrl_I,
menu_info,desk_menu));
NEW(POpenDialog,Init(@SELF,K_Ctrl,Ctrl_D,
menu_open_dialog,file_menu));
INHERITED InitInstance;
SetQuit(menu_quit,file_menu)
END;

Der Befehl erklÑrt sich ja schon fast von selbst. Das einzige, was es 
dazu noch zu sagen gÑbe, ist, daû LoadMenu nicht nur das MenÅ lÑdt, sondern auch 
noch darstellt und mit der Verwaltung beginnt.

So wie wir schon im Dialog jedem einzelnen Button ein Objekt zugeordnet hatten, 
machen wir es jetzt auch mit den einzelnen MenÅ-Punkten.

NEW(PInfoMenu,Init(@SELF,K_Ctrl,Ctrl_I,
menu_info,desk_menu));

Das kennen wir ja schon. Wir instantiieren ein neues Objekt (diesmal vom 
abgeleiteten Typ PInfoMenu von ) und initialisieren es mit dessen 
Constructor Init. Dabei legen wir fest, daû das Objekt zum MenÅ-Eintrag 
menu_info in der Spalte desk_menu gehîrt (ich setze bei MenÅ-EintrÑgen immer 
ein vorangestelltes "menu_" und bei den Titel ein hintenangestelltes "_menu"). 
Auûerdem soll dieser MenÅ-Punkt selektiert werden, wenn gedrÅckt 
wird.
Analog lÑuft das dann mit dem Objekt POpenDialog.

Wenn nun ein MenÅ-Punkt, der zu einem entsprechenden -Objekt gehîrt, 
selektiert wird, dann wird die Methode Work dieses Objektes gestartet. Damit 
etwas passiert, wenn unsere beiden MenÅ-Punkte selektiert werden, mÅssen wir 
natÅrlich noch die beiden Methoden und TInfoMenu.Work
Åberschreiben.

In die Methode TOpenDialog.Work schieben wir einfach den Inhalt unseres alten 
InitMainWindow, wir bauen hier also unseren Dialog auf - und diesmal macht die 
Abfrage, ob der Dialog schon installiert ist, auch Sinn, denn wir kînnen den MenÅ-
Punkt zum ôffnen des Dialog-Fensters mehrmals aufrufen (sogar wenn der Dialog 
gerade offen ist). Bei der Installation des Dialoges benutzen wir jetzt 
Åbrigens die Variable (die zum Objekt TKeyMenu gehîrt). ADialog ist 
ein Pointer, der auf ein Dialog-Objekt, daû zu diesem MenÅ-Eintrag gehîrt, 
zeigen soll.

Wenn der oberste MenÅ-Punkt im Desk-MenÅ selektiert wird, dann soll ein 
einfacher Dialog (ohne einen einzigen Button - man kann ja einfach das Fenster 
zumachen, wenn man den Dialog beenden will) aufgerufen werden. Aber das ist ja 
jetzt ein alter Hut, und deshalb verliere ich darÅber auch kein Wort mehr.

Wir haben in diesen beiden beiden Beispiel-Programmen keine einzige Abfrage 
Åber irgendwelche GEM-Aktionen selber machen mÅssen. Wir haben bisher nicht 
mal eine einzige eigene Prozedur geschrieben, sondern nur bestehende Methoden 
Åberschrieben. ObjectGEM liefert zu jedem GEM-Element einen eigenen Objekt-
Typ, und zu jeder Aktion des Users gibt es eine passende Methode, die dann 
aufgerufen wird. Wir brauchen uns also nur noch auf das Wesendliche zu 
konzentrieren, anstatt uns mit dem Event-Loop und der Abfrage von Events 
rumzuÑrgern.

Die ObjectGEM-Units werden wie gewohnt mit der -Klausel eingebunden. Dabei 
sollte folgende Reihenfolge eigehalten werden (abgesehen von nicht benîtigten 
Units):

uses

Objects, OTypes, OProcs, OWindows,
OValidat, ODialogs,OStdDlgs, OStdWnds, ODB;

Wenn zusÑtzlich noch andere Units eingebunden werden (z.B. Gem, Tos etc.), 
sollten diese davor eingebunden werden, es sei denn, die Units greifen auf 
Teile von ObjectGEM zurÅck.

Mit dem "BubbleHelp"-Hilfesystem kann sehr leicht eine kontextsensitive
Hilfe realisiert werden. Dazu kann -, -
und -Objekten (und davon abgeleiteten Objekten) in der
jeweiligen Init-Methode ein String Åbergeben werden, der von der
Dialogbehandlung ausgewertet wird. Im weiteren braucht dieser
Hilfstext nicht weiter beachtet zu werden, einzig interessant
ist noch die Methode SetHelp zum nachtrÑglichen éndern des
Textes.

Wenn man in einem Dialog den Mauscursor auf ein solches Dialogelement
bringt und die rechte Maustaste oder drÅckt, erscheint
an der Mausposition eine Sprechblase mit dem festgelegten
Hilfstext. Die Sprechblase bleibt mind. eine halbe Sekunde
(ObjectGEM-intern festgelegt) sichtbar, danach kann sie mit einem
Mausklick oder einem Tastendruck geschlossen werden.

FÅr die kontextsensitive Hilfe auûerhalb von Dialogen steht die
Methode zur VerfÅgung. Dort ist auch der
Aufbau der Hilfe-Strings beschrieben.

In Zukunft wird es evtl. einen sog. "stÑndigen Hilfemodus" geben,
bei dem eine Sprechblase erscheint, wenn sich der Mauscursor eine
gewisse Zeit Åber einem Dialogelement befindet (wie beim Mac
System 7). ObjectGEM legt dafÅr bereits jetzt den -Cookie
an, dessen Wert sich aus der Verzîgerung bis zur Aktivierung der
Hilfe (unterer Integer, -1=Hilfemodus aus) und der Mindestzeit
fÅr die Sichtbarkeit der Sprechblase (oberes Word) zusammensetzt.

Die Objekte , und besitzen das Feld
Clipboard, das auf ein -Objekt zeigt. Normalerweise gibt
es nur ein globales Clipboard-Objekt, falls aber eine Spezialisierung
notwendig sein sollte, steht die Methode GetClipboard zur VerfÅgung.

Um auf das Clipboard zugreifen zu kînnen (lesend oder schreibend),
muû man es mit OpenClipboard îffnen. Von GetClipboardFilename
erhÑlt man eine komplette Pfadangabe incl. Dateinamen fÅr das Klemmbrett -
nur die Extension fehlt noch (z.B. C:CLIPBRDSCRAP.).
Mit IsClipboardFormatAvailable und GetPriorityClipboardFormat
kann man komfortabel nach bestimmten Dateitypen im Klemmbrett
suchen, ansonsten kann man nun mit den "normalen" Dateifunktionen
auf das Klemmbrett zugreifen. Abschlieûend muû man das Klemmbrett
mit CloseClipboard wieder schlieûen und damit freigeben.

Hat man den Inhalt des Klemmbretts verÑndert, sollte man vorher
noch SetClipboardFormat aufrufen, damit die beim Schlieûen
verschickte SC_CHANGED-Message korrekt gesetzt werden kann.

Wichtig: Es kann immer nur ein TClipboard-Objekt Zugriff auf
das Klemmbrett haben. Wenn also ein Zugriff immer bereits beim
ôffnen scheitert, kann es sein, daû bei einem anderen Clipboard-
Objekt das Schlieûen vergessen wurde.

In ObjectGEM ist das Drag&Drop-Protokoll in der Version 1.1 implementiert.
Der Drag&Drop-Mechanismus steht nur unter MultiTOS zur VerfÅgung.

Wenn ein Programm Drag&Drop unterstÅtzen soll, mÅssen zumindest
die Methoden DDHeaderReply und DDReadData (bzw. DDReadArgs)
Åberschrieben werden. Das Einlesen der Daten muû in letztgenannter
Methode selbst vorgenommen werden. Da wÑhrend des Drag&Drop-
Protokolls der Bildschirm nicht blockiert werden darf, erhÑlt
man nach erfolgreicher Kommunikation in der Methode DDFinished
die Mîglichkeit, die Daten entsprechend auszuwerten.

Wenn der Aufbau der Kommunikation nicht unnîtig in die LÑnge
gezogen werden soll, muû dafÅr die Methode DDGetPreferredTypes
Åberschrieben werden, in der man die mîglichen Dateitypen einschrÑnken kann.

Soll das Programm auch auf den PATH-Parameter positiv antworten,
muû DDGetPath effektiv gemacht werden.

ObjectGEM stellt eine erweiterte Dialogbehandlung zur VerfÅgung.
Folgende Eigenschaften sind zusÑtzlich zu den Åblichen GEM-Mîglichkeiten
vorhanden:


Der Edit-Cursor kann mit der Maus verschoben werden
Folgende Tastenkombinationen stehen in einem Edit-Feld zur VerfÅgung:



geht zum vorherigen Eingabefeld



geht zum nÑchsten Eingabefeld



Cursor innerhalb des Feldes bewegen

Cursor an Feldanfang

Cursor an Feldende



Cursor auf erstes Eingabefeld



Cursor auf letztes Eingabefeld

Zeichen links vom Cursor lîschen

Zeichen rechts vom Cursor lîschen

Feld lîschen

s.u.


Jedes Eingabefeld, dem ein -Objekt zugeordnet ist, merkt
sich die Position des Edit-Cursors bis zur nÑchsten Aktivierung.
Auûerdem kann mit die letzte énderung rÅckgÑngig
gemacht werden.
Dialogelemente, bei denen ein Buchstabe unterstrichen angezeigt
wird, kînnen mit aktiviert werden.
-Objekte, bei denen cs_WorkBackground gesetzt ist (das
ist die Standard-Einstellung), kînnen auch im Hintergrund
bedient werden. Um ein solches Dialogfenster wieder in den
Vordergrund zu holen, muû man einen Doppelklick rechts auf
den Arbeitsbereich des Fensters ausfÅhren.
Modale Dialogekînnen durch Anklicken eines inaktiven Dialogelements
(z.B. Text oder der Hintergrund) bei gedrÅckter
linker Maustaste verschoben werden.
Bei einem Klick auûerhalb eines modalen Dialogs wird dieser um
den Mauszeiger zentriert.
Befindet sich der Mauscursor Åber einem Dialogelement, dem ein
TControl-Objekt zugeordnet ist (das sollte bei den meisten der
Fall sein), kann mit der rechten Maustaste oder mit die
sog. aufgerufen werden.

Mit cs_WorkBackground kînnen Fenster dazu gebracht werden, daû
man sie im Hintergrund bedienen kann (unter allen TOS-Versionen).
Dies gilt natÅrlich nur fÅr den Arbeitsbereich, die
Fensterkomponenten kînnen nur im Hintergrund angewÑhlt werden,
wenn das Betriebssystem dies unterstÅtzt (z.B. MultiTOS, WINX).
Solche Fenster kînnen nur noch durch Anklicken einer Fenster-Komponente
(Titelzeile etc.) getoppt werden, oder - dies ist
ein ObjectGEM-spezifisches Feature - mit einem Doppelklick rechts
im Arbeitsbereich!

In den TWindow-Fensterobjekten sind z.Z. folgende Tastatur-Shortcuts
vorgesehen (#bedeutet, daû die Taste im Ziffernblock
gemeint ist):


WÑhlt alle passenden Elemente im Fenster aus

(siehe )

FÅhrt die "Kopieren"-Operation durch

(siehe )

Druckt den Fensterinhalt aus

(siehe bzw. TTextWindow.Print)

Schlieût das Fenster

FÅhrt die "EinfÅgen"-Operation durch

(siehe )

Wechselt die Fenster der Applikation zyklisch

(mit in umgekehrter Reihenfolge)

FÅhrt die "Ausschneiden"-Operation durch

(siehe )

# Bringt das Fenster auf Maximalgrîûe

# Bringt das Fenster in den Hintergrund (AES 4.0)

# Ikonifiziert das Fenster (nur mit ICFS)

FÅhrt die "Entfernen"-Operation durch

(siehe )

VerlÑût das Programm

(dies ist eigentlich kein Fenster-Shortcut)


Ab AES 4.10 unterstÅtzt ObjectGEM Iconification, d.h. GetStyle
liefert zusÑtzlich den Wert SMALLER zurÅck, und im Fenster erscheint
links neben dem Fuller noch der "Verkleinerungsknopf".

Wenn dieser Button angewÑhlt wird, wird das entsprechende Fenster
ikonifiziert. Dem Icon-Fenster kann per GetIconTitle ein neuer
Titel zugewiesen werden, auûerdem wird bei einem Redraw nun die
Methode IconPaint aufgerufen. Der Status eines Fensters lÑût sich
mit IsIconified abfragen.

Wenn beim Anklicken des SMALLERs zusÑtzlich 
gedrÅckt wird, wird die gesamte Applikation ikonifiziert, d.h. alle
Fenster werden in einem Icon-Fenster zusammengefaût. DafÅr
stehen Ñhnliche Funktionen wie bei einem Fenster zur VerfÅgung.
Wichtig: Hierbei werden die Fenster der Applikation nicht
geschlossen, sondern nur rechts so weit Åber den Bildschirmrand
geschoben, daû man sie nicht mehr sieht und der Benutzer keine
Aktionen mehr an ihnen durchfÅhren kann. FÅr die Applikation
wird dann ein neues Icon-Fenster geîffnet.

Soll in einem ikonifizierten Fenster automatisch ein Icon angezeigt
werden, muû aufgerufen werden. Damit auch
bei einem Applikations-Icon-Fenster ein Icon erscheint, steht die
Methode zur VerfÅgung. Dialoge Åbernehmen
dieses Icon automatisch, wenn ihnen kein eigenes Icon zugewiesen
wird.

Ist ein ICFS-Server installiert, so ist Iconification auch unter
alten TOS-Versionen mîglich. Wird beim Anklicken der CLOSERs
gedrÅckt, wird das Fenster ikonifiziert. Das
Verkleinern aller Fenster mit ist aus technischen
GrÅnden (noch) nicht mîglich bzw. sinnvoll. In einer spÑteren
Version wird es allerdings auch die ICFS-Iconification mit
geben (alle Fenster werden einzeln verkleinert).
ObjectGEM liegt der ICFS-Server von Dirk Haun und das ICFS-CPX
von John McLoud bei.

Ikonifizierte Fenster oder Applikationen erhalten von ObjectGEM
nur noch Timer- sowie ausgesuchte Message-Events. Evtl. kann in
Zukunft aber ein Flag gesetzt werden, so daû auch in einem Icon-Fenster
Aktionen durchgefÅhrt werden kînnen.

In den -MenÅs ist folgende Tastatursteuerung vorgesehen:


WÑhlt den markierten Eintrag aus




Bricht das Popup-MenÅ ab



Bringt die Markierung auf den ersten Eintrag



Bringt die Markierung auf den letzten Eintrag



Bewegt die Markierung nach oben

Bewegt die Markierung nach unten


Mit den ObjectGEM-Profile-Routinen kînnen die bei vielen Applikationen
vorhandenen INF-Dateien sehr leicht realisiert werden.
Sie haben auûerdem den Vorteil, daû sie als ASCII-Texte
verwaltet werden, so daû sie - wenn nîtig - auch "von Hand"
verÑndert werden kînnen.

Auûerdem werden - wenn die Environmentvariable HOME und das Flag
as_UseHomeDir gesetzt ist - diese Konfigurationsdateien an einem
zentralen Ort (eben dem User-Home-Verzeichnis) gespeichert, so
daû auch eine Multi-User-Umgebung realisierbar ist. Wenn 
nicht gesetzt ist, werden die Dateien wie gewohnt im Ordner der
Applikation angelegt.

Ein Profile setzt sich aus Blîcken zusammen. Jeder Block hat eine
"öberschrift" (in eckigen Klammern, bei den Profile-Routinen auch
mit "Anwendungsname" bezeichnet). Nach diese öberschrift folgen
die SchlÅsselnamen mit den zugehîrigen Werten, Leerzeilen sind
nur zum Trennen der Blîcke erlaubt. Kommentare beginnen mit einem
Semikolon oder # am Zeilenanfang, Kommentarblîcke werden mit ## eingeschlossen.
Ein Eintrag innerhalb eines Profiles
muû durch den Anwendungs- und SchlÅsselnamen eindeutig bestimmt
sein, ansonsten wird nur das erste Vorkommen beachtet.
Ein Profile kînnte also z.B. so aussehen:


; Das ist ein Kommentar innerhalb eines Profiles
# das auch
[Block 1]
Var_1=Test-Text
Var_2=42

## hier beginnt ein Kommentarblock
und in der nÑchsten Zeile hîrt er auf
##
[nÑchster Block]
Var_2=die hat nichts mit o.g. Variable zu tun
Var_3=2147483647
Hallo.Welt=Das ist ein Test!

Zum Auswerten eines Profiles stehen Routinen fÅr ganze Zahlen
(GetPrivateProfileInt, WritePrivateProfileInt) und fÅr
Zeichenketten (GetPrivateProfileString, WritePrivateProfileString) zur
VerfÅgung. Sollen Flieûkommazahlen bearbeitet werden, muû man
diese in Zeichenketten umwandeln (z.B. mit ftoa, atof).

Profiles, die direkt auf einer Datei arbeiten, sind recht langsam,
vor allem beim Schreiben. Deshalb besteht die Mîglichkeit,
ein Profile mit OpenPrivateProfile in den Speicher zu laden, wo
die Bearbeitung deutlich schneller ist. Da immer nur ein Profile
im Speicher verwaltet werden kann, werden Zugriffe auf andere
Profiles weiterhin direkt auf der Platte (bzw. Diskette) durchgefÅhrt.
ClosePrivateProfile braucht nicht explizit aufgerufen
zu werden, dies geschieht automatisch beim Programmende. Man
sollte allerdings nach dem Schreiben von Daten immer die Routine
SavePrivateProfile aufrufen, da man z.B. bei Accessories nicht
davon ausgehen kann, daû die Applikation verlassen werden kann.

Die oben erwÑhnten Routinen bearbeiten private Profiles, d.h.
Applikations-spezifische Konfigurationsdateien. Da es aber auch
wÅnschenswert sein kann, bestimmte Werte systemglobal festzulegen,
ist z.Z. eine Datei in der Diskussion, die von
allen Applikationen verwendet werden kann. FÅr diese Datei stehen
spezielle Routinen zur VerfÅgung (GetProfileString etc.). Da
die Standardisierung aber noch nicht abgeschlossen ist, kann sich
am Namen, Ort, Inhalt etc. der Datei noch etwas Ñndern.

Folgendes sollte bei der Resource-Erstellung fÅr ObjectGEM
beachtet werden:


Das hîherwertige Byte von ob_type (AESOBJECT) darf unter
ObjectGEM weder verwendet noch verÑndert werden! Abgesehen
davon, daû es eine Zeit lang unter MultiTOS Probleme mit
solchen Programmen gegeben hat, benîtigt ObjectGEM dieses
Byte fÅr interne Zwecke. Durch den objektorientierten Ansatz
und die TControl-Schnittstellenobjekte sollte die Verwendung
dieses Bytes allerdings auch nicht nîtig sein.
Alle mit ObjectGEM verwendeten Resourcen sollten wie folgt
sortiert sein (eine entsprechende Option sollte in jedem RCS
zu finden sein):


1 2 3
4 5 6

Die korrekte Grîûe fÅr Dialogelemente, denen spÑter ein
TCheckBox-, TRadioButton- oder TTriState-Objekt zugeordnet
werden soll, kann wie folgt bestimmt werden: Man nimmt im RCS
ein BUTTON-Element und verÑndert den Text wie gewÅnscht. An
den Text werden allerdings noch drei (bzw. zwei, wenn eine
Shortcut-Markierung verwendet wird) Leerzeichen angehÑngt.
Nun wird das BUTTON-Element vom RCS entsprechend lang gezeichnet.
Zum Schluû lîscht man die Leerzeichen wieder, verÑndert
die Grîûe des BUTTON-Elements allerdings nicht mehr.
Im ObjectGEM-Programm werden die neuen Buttons nun korrekt
gezeichnet.
Bei den Objekten TCheckBox/TTriState wird der selektierte Zustand
normalerweise als HÑkchen dargestellt. Wenn in der Resource
allerdings das Flag CROSSED gesetzt ist, werden daraus
"AnkreuzkÑstchen".
Toolbar-Elemente werden unter neueren TOS-Versionen automatisch
mit 3D-Effekten versehen, wenn sie vom Typ G_BOX, G_BOXTEXT,
G_BUTTON, G_BOXCHAR oder G_FBOXTEXT sind. Elemente vom Typ
G_BOXTEXT oder G_FBOXTEXT sollten mit dem kleinen Zeichensatz
sowie den Stati SHADOWED und OUTLINED versehen werden; dadurch
haben sie einen Pseudo-3D-Effekt, der ab AES 3.40 automatisch
durch den "echten" Effekt ausgetauscht wird.
Wenn ein Toolbar-Button nicht mit einem TToolbar-Objekt
verknÅpft wird (siehe "Toolbars"), muû in ob_state SELECTABLE
gesetzt sein.
Wenn bei InitResource/LoadResource zwei RSC-Dateien fÅr die
unterschiedlichen Auflîsungen verwendet werden, muû man daran
denken, daû die Indizes der Objekte in beiden Dateien gleich
sein mÅssen, da nur eine Include-Datei verwendet werden
kann.
ObjectGEM kommt auch mit RSC-Dateien zurecht, in denen das
pe_tvalid-Feld verkÅrzt ist. Die nîtigen Zeichen der Maske
werden ergÑnzt.
In stehen folgende Zeichen zusÑtzlich zur VerfÅgung:

"H" fÅr Hexadezimalzahlen: "0".."9", "a".."f", "A".."F"
"D" fÅr Dezimalzahlen: "0".."9", "+", "-", ",", "."
"+" fÅr Vorzeichen: "+", "-"

Fenster-Toolbars bestehen aus ganz normalen Dialog-BÑumen in der
Resource-Datei, die in SetupWindow mittels LoadToolbar mit dem
Fenster verknÅpft werden. Um eine einfach Bearbeitung zu gewÑhrleisten,
sollten danach alle Toolbar-Buttons mit -Objekten verknÅpft
werden, die als Schnittstellenobjekte dienen.

Eine andere Mîglichkeit sind Anwender-konfigurierbare Toolbars.
Dabei kann der spÑtere Anwender des Programms sich seine Toolbar-Buttons
mit einem Resource Construction Set zusammenstellen.
Diese Buttons werden nicht mit TToolbar-Objekten verknÅpft
(der Programmierer kann ja nicht alle AnwenderwÅnsche berÅcksichtigen),
sondern Åber den erweiterten Objekttyp mit einem
MenÅeintrag in der MenÅleiste der Applikation. Dieses ist die
einzige Situation, in der die Verwendung des hîherwertigen
Bytes von ob_type unter ObjectGEM gestattet ist!!!

Findet der Toolbar-Dispatcher im hîherwertigen Byte eine Null
vor (das sollte bis jetzt immer der Fall sein), passiert gar
nichts. Ist dort allerdings ein Wert ungleich Null eingetragen,
wird MNSelected mit eben diesem Wert als Index des gewÑhlten
MenÅeintrags aufgerufen.

Wichtig: Dieser Mechanismus funktioniert auch, wenn TToolbar-Objekte
eingesetzt werden, d.h. der Programmierer kann diesen
Effekt bewuût ausnutzen. Der Aufruf erfolgt in diesem Fall
nach dem Aufruf der Work-Methode.

Wenn Anwender-konfigurierbare Toolbars eingesetzt werden, muû
der Programmierer dafÅr sorgen, daû die Indizes der MenÅeintrÑge
dokumentiert werden. Auûerdem wÑre es nett, wenn dem Anwender
dann z.B. Mini-Icons fÅr die wichtigsten Funktionen zur VerfÅgung
gestellt wÅrden.

ObjectGEM verwendet das XAcc-Protokoll nach der Definition vom
28.11.1992, d.h. auch unter MultiTOS ist die korrekte Protokoll-Behandlung
gesichert.

Als Programmierer braucht man sich nicht um die Einzelheiten
des Protokolls kÅmmern, sondern man kann direkt das Ergebnis
in der XAccList (z.B. per TApplication.FindApplication)
auswerten. Die einzig interessante "Verwaltungs"-Routine dÅrfte
TApplication.XAccInsert sein.

Die XAcc-Eigenschaften des ObjectGEM-Programms werden in der
Methode TApplication.GetXAccAttr festgelegt. Wenn man also
besondere Eigenschaften kennzeichnen mîchte, muû man diese
Methode Åberschreiben. Man kann dort auch die "Extended names"
festlegen, die dann von ObjectGEM automatisch korrekt verschickt
werden.

Wichtige Methoden fÅr das XAcc-Protokoll sind diejenigen, mit
denen ein Datenaustausch durchgefÅhrt werden kann. Dies sind
die TApplication-Methoden XAccText, XAccKey, XAccMeta und
XAccIMG. Diese Methoden dienen zum Empfangen von Daten; ein
Verschicken wird z.Z. von ObjectGEM noch nicht direkt unterstÅtzt.

ObjectGEM wertet auûerdem das AV-Protokoll aus. Dies geschieht
ebenfalls automatisch, und es werden die gleichen Datenstrukturen
verwendet. Wie beim XAcc-Protokoll dÅrfte auch nur die Methode
TApplication.AVInsert interessant sein, alle spezifischen AV-Messages
werden weiterhin an TApplication.HandleAV weitergeleitet.
Ist ein AV-Server vorhanden, befindet sich seine AES-ID
im Feld TApplication.AVServer.

In den Dialogen sollte so oft wie mîglich die "BubbleHelp" unterstÅtzt werden 
(siehe TControl). Ein Hilfesystem bringt nur dann etwas, wenn es konsequent 
eingesetzt wird.

ObjectGEM unterstÅtzt neue, zu BP 7.0 kompatible Runtime-Errors:


Fehler-Nr. Bedeutung

		211 Aufruf einer abstrakten Methode

		("Call to abstract method")

		Dieser Fehler wird normalerweise von der Prozedur

		Abstract ausgelîst und zeigt an, daû Sie einen

		abstrakten Objekttyp nicht abgeleitet und die

		entsprechenden Methoden Åberschrieben haben;

		TSortedCollection ist ein Beispiel dafÅr

		213 Kollektion-Index auûerhalb des gÅltigen Bereichs

		("Index range error")

		Einer TCollection-Methode wurde ein ungÅltiger

		Index Åbergeben (d.h. zu klein/groû).

		214 Kollektion-öberlauf

		("Collection overflow")

		Die Kollektion kann kein neues Element mehr

		aufnehmen, d.h. der Speicher ist voll.


FÅr viele Fenster-Routinen etc. stellt ObjectGEM "neue" Methoden zur VerfÅgung, 
die statt der alten verwendet werden sollten (bzw. mÅssen); z.B. muû statt
wind_calc nun die TWindow-Methode WindCalc aufgerufen werden.
Dadurch ist es sauber geschriebenen Programmen dann egal, ob z.B. noch eine
Toolbar oder eine MenÅleiste im Fenster installiert wird, da ObjectGEM nun fÅr
die Verwaltung des Work-Bereichs etc. zustÑndig ist.

alte Funktion										"neue" Methode

	evnt_timer(1,0) appl_yield
hline
	form_alert											TApplication.Alert

	form_dial(FMD_FINISH)		TWindow.ForceRedraw

	Neuzeichnen des Fensters			TWindow.WMRedraw

																		TApplication.InvalidateRect

		Neuzeichnen des Desktops				TApplication.DeskRedraw

	form_do													TApplication.ExecDialog

																		(besser TDialog verwenden!)

		Popup-MenÅs											TApplication.Popup

fsel_input									FileSelect

fsel_exinput 

GetFreeString										TApplication.GetFString

graf_mouse(ARROW) ArrowMouse

graf_mouse(BUSYBEE) BusyMouse

graf_mouse(M_OFF) HideMouse

graf_mouse(M_ON) ShowMouse

	menu_bar												TApplication.LoadMenu

																		TApplication.DrawMenu

																		TApplication.FreeMenu

	objc_change								SetState, GetState,

		éndern des Objektstatus				Enable, Disable,

																	SetText, GetText,

																	SetCheck, GetCheck,

																	Check, Uncheck,

																	Toggle, Gray

	rsrc_free												TApplication.FreeResource

	rsrc_gaddr											TApplication.GetAddr

																		TApplication.GetFImagePtr

																		TApplication.GetFStringPtr

	rsrc_load												TApplication.LoadResource

																		TApplication.InitResource

	wind_calc												TWindow.WindCalc

	wind_close											TWindow.CloseWindow

	wind_create											TWindow.Create

	wind_delete											TWindow.Destroy


alte Funktion										"neue" Methode

	wind_get(WF_CURRXYWH)			TWindow.GetCurr

	wind_get(WF_FULLXYWH)			TWindow.GetFull

	wind_get(WF_WORKXYWH)			TWindow.GetWork

	wind_get(DESK,WF_WORKXYWH) GetDesk

	wind_open												TWindow.OpenWindow

	wind_set(WF_CURRXYWH)			TWindow.SetCurr

																		TWindow.SetWork

																		TWindow.FullSize

	wind_set(WF_INFO)			TWindow.SetSubTitle

		WindSetInfo 

	wind_set(WF_NAME)			TWindow.SetTitle

		WindSetTitle 

	wind_set(DESK,WF_NEWDESK)				TApplication.InstallDesktop

																		TApplication.RemoveDesktop

	wind_set(WF_TOP)						TWindow.Top

Programm verlassen							TApplication.Quit

																		(geschieht, wenn nicht anders

																		angegeben, beim Schlieûen eines

																		Fensters automatisch, siehe

																		Beispielprogramme)


[15mm]

Im globalen Record stehen die aktuellen, fÅr ObjectGEM gÅltigen VDI-Attribute,
die auch von Programmen genutzt werden kînnen. Es ist allerdings 
nicht sicher, daû dieser Record "bis in alle Ewigkeit" unterstÅtzt wird. Es 
existiert deshalb zwar die Routine ; Programme sollten nach 
Mîglichkeit aber den Zugriff auf GP vermeiden (im Gegensatz zum bisher 
Dokumentierten)!!!

Die Unit installiert eine neue -Funktion,
die bei Fehlschlagen einer Speicheranforderung einen nil-Pointer zurÅckgibt.
wird von OWindows umgelenkt, so daû bei einem
auûerordentlichen Programmabbruch noch versucht werden kann, ein
evtl. angelegtes Applikations-Objekt freizugegeben.
Wenn SpeedoGDOS installiert ist, werden die Speedo-Fehlermeldungen
mittels vst_error so umgeleitet, daû diese nicht mehr
auf dem Bildschirm angezeigt werden, sondern mit ChkSpeedoError
abgefragt werden kînnen.
Ist MiNT oder MultiTOS aktiv, lenkt TApplication.InitGEM die
Signale SIGTERM und SIGQUIT auf einen eigenen Handler um, damit
die Applikation korrekt verlassen werden kann.
Wenn appl_getinfo vorhanden ist, wird diese Auskunftsfunktion
verwendet, um spezielle Systemeigenschaften zu ermitteln (so
wird die Mag!C-Anpassung realisiert). FÅr das Vorhandensein der
Routine werden AES- bzw. Mag!C-Version getestet sowie die ?AGI-
Methode unterstÅtzt (appl_find('?AGI')=0).
Ist MultiTOS vorhanden, wird zur Clipboard-Blockierung das AES-interne
-Semaphor verwendet.
Wenn Let'em Fly installiert ist, wird die Dialog-Flugroutine
sowie die Routine beim Klick auûerhalb des Dialogs fÅr modale
Dialoge verwendet.
Der -Cookie (Virtual Screen) wird beachtet.
WINX ab Version 2.2 wird direkt unterstÅtzt, z.B. durch die
WMArrowed-Methode (Scrollboxen).

Die GEM-Message GO_PRIVATE ($1235) wird intern mit folgenden
Sub-Opcodes in msg[3] verwendet:


GOP_GETVERSION 0 dient als Aufforderung, eine

GOP_VERSION-Message zu schicken

GOP_TOOLBAR 1 siehe TToolbar.TestMessage

GOP_SETQUIT 2 wird von LoadMenu verschickt, um den

MenÅeintrag (msg[4]) und -titel (msg[5])

fÅr das -Objekt zu setzen;

beim Empfang dieser Message ruft

MUMesag die Methode SetQuit auf

GOP_VERSION $7fff wird als Antwort auf GOP_GETVERSION

verschickt; in msg[4] erhÑlt man die

jeweilige GOVersion


ObjectGEM setzt die Ideen von ObjectWindows fÅr BorlandPascal unter Windows
fÅr das Atari-GEM um. Abgesehen von offensichtlichen Unterschieden
(z.B. beim Event-Handling) gibt es aber auch noch andere, die hier
besprochen werden sollen.

In ObjectGEM sind die meisten Methoden virtuell, wodurch es besser mîglich sein 
sollte, in den Programmablauf - wenn nîtig - einzugreifen.

Auûerdem wird in ObjectGEM recht wenig vom Typ PChar Gebrauch gemacht. Dies 
dient zum einen zur einfacheren Programmierung (normale Strings reichen 
meistens aus), zum anderen gab (und gibt) es offensichtlich Probleme mit den 
nullterminierten Strings und der zugehîrigen Unit.

Im folgenden sind Routinen aufgelistet, die zwar nicht 100% kompatibel, aber 
zumindest recht Ñhnlich sind:


ObjectWindows/Windows ObjectGEM


BringWindowToTop TWindow.Top

	CheckDlgButton SetCheck

	GetActiveWindow TApplication.GetPTopWindow

	GetClientRect TWindow.GetWork

	GetDesktopWindow DESK

	GetVersion GEMVersion

MiNTVersion

TOSVersion

GetWindowRect TWindow.GetCurr

IntersectRect rc_intersect

MapVirtualKey MapKey

MessageBox TApplication.Alert

PostQuitMessage TApplication.Quit

Yield appl_yield


"Objektorientierte Programmierung: Philosophie des Programmierens, die von einer
Welt ausgeht, die aus gleichberechtigten und einheitlich erscheinenden Objekten
besteht..." Das sagt zumindest der Duden "Informatik". Und wer das jetzt sofort
und uneingeschrÑnkt verstanden hat, sollte gar nicht mehr weiterlesen, denn er
(oder sie) wird am folgenden keinen Spaû, geschweige denn irgend eine wichtige
Information finden.

Was nun aber ist OOP wirklich? Normalerweise wird OOP nicht konkret definiert,
sondern vielmehr durch Beispiele erklÑrt und mit Metaphern umschrieben. Und so
wollen auch wir uns diesem mysteriîsen Begriff ein wenig nÑhern.

Normalerweise fangen alle ErklÑrungsversuche jetzt an, eine Objekthierarchie
von Grafikelementen aufzustellen (Werte, Punkte, Linien...). Es gibt aber auch
einen interessanteren Ansatz. Wieviele verschiedene Obstsorten haben Sie gerade
bei sich in der KÅche? Sicherlich eine ganze Menge. Und all diese Sorten lassen
sich schîn Åbersichtlich in verschiedene Klassen einteilen (SÅdfrÅchte,
BeerenfrÅchte, Kernobst, bestrahltes Obst, gespritztes Obst...). Man kann aber
auch etwas ganz anderes damit machen.

FÅr 6 Personen

750g gemischtes Obst (Birnen, Nektarinen,

Aprikosen, Erd- und Johannisbeeren)

2EL Ahornsirup

2cl Aprikosenlikîr

1 Vanilleschote

50g weiche Butter

50g Puderzucker

1 Ei, Salz

100g Mehl

1-2EL Milch

2 Eigelb

1/8l Marsalawein

1EL Zitronensaft


[2mm]

Das Obst waschen, abtrocknen, zerkleinern und mit Sirup sowie Likîr mischen.
Das Vanillemark aus der Schote schaben und mit Butter, Puderzucker, Ei,
1 Prise Salz, Mehl und Milch zum dÅnnflÅssigen Teig verrÅhren. Diesen
sofort zu 6 PlÑtzchen ( 12cm) auf Backpapier streichen und im
200 Grad (Gas: Stufe 3) heiûen Ofen in 12-15 Minuten goldgelb werden
lassen. Noch heiû Åber umgestÅlpten GlÑsern rund formen. Eigelb mit
Marsala und dem Zitronensaft im heiûen Wasserbad schaumig schlagen.
Den Obstsalat in die kalten, zu SchÑlchen geformten PlÑtzchen fÅllen und mit der
Weinschaumsauce Åberziehen. Fertig!

Sei nun die Folge der Kalorien.
Diese kann dann wesentlich einfacher mit 
berechnet werden.

Nun ja, zugegeben, soooo viel haben wir Åber OOP in diesem Kapitel nicht erfahren,
aber der Obstsalat schmeckt wirklich gut!

meyer Bertrand Meyer, Objektorientierte Softwareentwicklung,
Hanser, Wien; Prentice Hall, London (1990)
profi Jankowski, Rabich, Reschke, Atari Profibuch, 10. Auflage, 
SYBEX, D"usseldorf (1992)

compendium Scott Sanders, The ATARI Compendium,
SDS Publishing (1993)
geiss Dieter Geiû, JÅrgen Geiû, Vom AnfÑnger zum GEM-Profi,
HÅthig Buch Verlag, Heidelberg (1990)
NVDI Sven Behne, Wilfried Behne, NVDI-Dokumentation, 
BELA

falcon Hendricks, Herzlinger, Pittelkow, Das Buch zum Atari Falcon030, 1. Auflage,
Data Becker, DÅsseldorf (1992)
intern BÑr, Bauder, Windows 3.1 intern, 1. Auflage,
Data Becker, DÅsseldorf (1992)
tpwow Ertl, Machholz, TurboPascal fÅr Windows - ObjectWindows,
SYBEX, DÅsseldorf (1992)
borland1 BorlandPascal 7.0, ObjectWindows Programmierhandbuch,
Borland (1992)
borland2 Borland C++ 4.0, ObjectWindows Referenzhandbuch,
Borland (1993)
borland3 Paradox 4.0, PAL-Programmierhandbuch,
Borland (1992)
formate GÅnter Born, Referenzhandbuch Dateiformate, 2. Auflage, 
Addison-Wesley, Bonn (1992)

formate2 GÅnter Born, Dateiformate Programmierhandbuch, 
Addison-Wesley, Bonn (1993)

latex Helmut Kopka, : eine EinfÅhrung, 4. Auflage,
Addison-Wesley, Bonn (1992)

gkp Graham, Knuth, Patashnik, Concrete Mathematics, 7. Auflage,
Addison-Wesley (1991)
duden Hermann Engesser (Hrsg.), Duden Informatik, 2. Auflage,
Dudenverlag, Mannheim (1993)
kochen meine Familie & ich, Kochen & backen mit Obst,
Burda (1991)
adams Douglas Adams, Per Anhalter durch die Galaxis; Das
Restaurant am Ende des Universums; Das Leben, das Universum und der
ganze Rest; Macht's gut und danke fÅr den Fisch; Dirk Gently's
Holistische Detektei, Der lange, dunkle FÅnfuhrtee der Seele;
The Hitch Hiker's Guide to the Galaxy; The Restaurant at the End
of the Universe; Life, the Universe and Everything; So Long, and
Thanks for all the Fish; Mostly Harmless; Dirk Gently's holistic
Detective Agency; The long dark Tea-Time of the Soul; The Meaning
of Liff
tee Adrian, Temming, Vollers, Das Teebuch,
VMA Verlag, Wiesbaden (1989)
johnnie Walker, Red Label,
John Walker & Sons, Kilmarnock (MÅller lebt!)
camouflage Camouflage, Bodega Bohemia,
Metronome (1993)
amos Tori Amos, Under the Pink,
eastwest (1994)
neworder New Order, Republic,
CentreDate (1993)

